# Section 18

파드에서 실행되는 애플리케이션은 레플리케이션 컨트롤러, 레플리카셋, 디플로이먼트 또는 기타 확장 가능한 리소스 안에 있는 replicas 필드 값을 늘려 수동으로 확장할 수 있다.  
또한 파드는 컨테이너 리소스 요청 및 제한을 늘력 수직으로 확장하는 것도 가능하다. 스케일을 수동으로 제어하는 건 순간적인 부하를 예측할 수 있거나, 부하가 장시간에 걸쳐 점진적으로 
변화하는 경우에는 괜찮다. 하지만 갑자기 발생하는 예측할 수 없는 트래픽 증가 현상을 수동으로 개입해 처리하는 것은 이상적이지 않다.  

## 수평적 파드 오토스케일링

수평적 파드 오토스케일링은 컨트롤러가 관리 파드의 레플리카 수를 자동으로 조정하는 것을 말한다. 이것은 Horizontal 컨트롤러에 의해 수행되며,  
HorizontalPodAutoscaler 리소스를 작성해 활성화시키고 원하는 대로 설정한다. 컨트롤러는 주기적으로 파드 메트릭을 확인해,  
HorizontalPodAutoScaler 리소스에 설정돼 있는 대상 메트릭 값을 만족하는 레플리카 수를 계산한다. 그리고 대상 리소스 안에 있는 replicas 필드 값을 조정한다.  

### 오토 스케일링 프로세스 이해 

- 확장 가능한 리소스 오브젝트에서 관리하는 모든 파드의 메트릭을 가져온다. 
- 메트릭을 지정한 목표 값과 같거나 가깝도록 하기 위해 필요한 파드 수를 계산한다.  
- 확장 가능한 리소스의 replicas 필드를 갱신한다. 

#### 파드 메트릭 얻기 

오토 스케일러는 파드 메트릭을 수집하지 않고, 다른 소스에 메트릭을 가져온다.  
파드와 노드 메트릭은 모든 노드에서 실행되는 kubelet에서 실행되는 cAdvisor 에이전트에 의해 수집된다. 수집한 메트릭은 클러스터 전역 구성 요소인  
힙스터에 의해 집계된다. 수집한 메트릭은 클러스터 전역 구성 요소인 힙스터에 의해 집계된다. 수평적 파드 오토스케일러 컨트롤러는 힙스터에 REST를 통해  
질의해 모든 파드의 메트릭을 가져온다. 

![](https://github.com/keepinmindsh/lines_kubernetes/blob/main/assets/k8s_autoscaling_001.png)

#### 필요한 파드 수 계산  

오토스케일러의 스케일링 대상이 되는 리소스에 속해 있는 파드의 모든 메트릭을 가지고 있으면, 이 메트릭을 사용해 필요한 레플리카 수를 파악할 수 있다.  
모든 레플리카에서 메트릭의 평균 값을 이용해 지정한 목표 값과 가능한 가깝게 하는 숫자를 찾아야 한다. 이 계산의 입력은 파드 메트릭 세트이고,  
출력은 하나의 정수이다.  

오토 스케일러가 단일 메트릭만을 고려하도록 설정돼 있다면 필요한 레플리카 수를 계산하는 것은 간단하다. 모든 파드의 메트릭 값을 더한 뒤  
HorizontalPodAutoscaler 리소스에 정의된 목표 값으로 나눈 값을 그 다음으로 큰 정수로 반올힘해서 구한다. 실제 계산은 메트릭 값이   
불안정한 상태에서 빠르게 변할 때 오토스케일러가 같이 요동치지 않도록 하기 때문에 이보다 더 복잡하다.   

![](https://github.com/keepinmindsh/lines_kubernetes/blob/main/assets/k8s_autoscaling_002.png)

오토스케일링 여러 파드 메트릭을 기반으로 하는 경우 계산이 그렇게 복잡하지는 않다. 오토스케일러는 각 메트릭의 레플리카 수를 개별적으로 계산한 뒤 
가장 높은 값을 취한다.  

#### 스케일링된 리소스의 레플리카 수 갱신 

오토스켈링 작업의 마지막 단계는 스케일링 된 리소스 오브젝트 레플리카 개수 필드를 원하는 값으로 갱신해, 레플리카셋 컨트롤러가 추가 파드를 시작하거나 초과한 파드를 삭제하도록 하는 것이다.  
오토스케일러 컨트롤러는 스케일 대상 리소스의 replicas 필드를 스케일 서브 리소스를 통해 변경된다. 이는 스케일 서브 리소스를 통해 노출되는 것을 제외하고, 오토스케일러가 리소스의  
세부 사항을 알 필요 없이 수행할 수 있게 해준다. 

![](https://github.com/keepinmindsh/lines_kubernetes/blob/main/assets/k8s_autoscaling_003.png)

- 디플로이먼트 
- 레플리카셋 
- 레플리케이션 컨트롤러 
- 스테이트풀셋 

#### 전체 오토스케일링 과정 이해 

![](https://github.com/keepinmindsh/lines_kubernetes/blob/main/assets/k8s_autoscaling_004.png)

파드에서 cAdvisor로 이어지는 화살표는 힙스터를 지나 수평적 파드 오토스케일러에서 끝난다. 이 화살표는 메트릭 데이터의 흐름을 나타낸다.  
여기서 중요한 점은, 각 구성요소는 메트릭을 다른 구성 요소에서 주기적으로 가져온다는 것이다.  결과적으로 메트릭 데이터가 전파돼 재조정 작업이  
수행되기까지는 시간이 걸린다. 

### CPU 사용률 기반 스케일링

오토스케일링 기반이 되는 가장 중요한 메트릭으로는 파드 내부 프로세스가 소비하는 CPU 사용량일 것이다.  
서비스를 제공하는 파드가 몇 개 있다고 가정하자. 
CPU 사용량이 100%에 도달하면 더 이상 요구에 대응할 수 없어 스케일 업이나 스케일 아웃이 필요하다. 
여기서 우리는 수평적 파드 오토스케일러만 얘기하고 있기 때문에 스케일 아웃에 관해서만 집중해보자.  
스케일 아웃이 이루어지면 평균 CPU 사용량은 줄어들 것이다.  

--- 

오토스케일러에 한해서는 파드의 CPU 사용률을 결정할 때 파드가 보장받은 CPU 사용량만이 중요하다. 오토 스케일러는 파드의 실제 CPU 사용량과 CPU 요청을 비교하는데  
이는 오토스케일링이 필요한 파드는 직접 또는 간접적으로 LimitRange 오브젝트를 통해 CPU 요청을 설정해야 한다는 것을 의미한다.  

> 항상 목표 CPU 사용량을 100%에 훨씬 못미치게 설정해, 갑자기 순간적인 부하가 발생하는 것을 제어하는데 필요한 공간을 확보해야 한다. 

#### CPU 사용량을 기반으로 HorizontalPodAutoscaler 생성 

```yaml
apiVersion: extensions/v1beta1 
kind: Deployment 
metadata: 
  name: kubia 
spec:
  replicas: 3 
  template: 
    metadata: 
      name: kubia 
      labels: 
        app: kubia 
    spec: 
      containers:
      - image: luksa/kubia:v1 
        name: nodejs 
        resources: 
          requests: 
            cpu: 100m 
```

```shell
$ kubectl autoscale deployment kubia --cpu-percent=30 --min=1 --max=5 
```

HPA 오브젝트를 생성하고 kubia 디플로이먼트를 스케일링 대상으로 설정한다. 파드의 목표 CPU 사용률을 30%로 지정하고  
최소 및 최대 레플리카 수를 지정한다. 오토스케일러는 CPU 사용률을 30%대로 유지하기 위해 레플리카 수를 지정한다.  
오토스케일러는 CPU 사용륭을 30%대로 유지하기 위해 레플리카 수를 계속 저장하지만 1개 미만으로 줄이거나 5개를 초과하는 레플리카를 만들지는 않는다. 

> 항상 레플리카셋이 아닌 디플로이먼트를 오토스케일 대상으로 해야 한다.  
> 이렇게 하면 애플리케이션 업데이트 시에도 원하는 레플리카 수를 계속 유지할 수 있다. 
> 수동 스케일링에도 동일한 규칙이 적용된다. 

```yaml
$ kubectl get hpa.v2beta1.autoscaling kubia -o yaml 
```

#### 최초 오토 리스케일 이벤트 보기 

```shell
$ kubectl get hpa 

$ kubectl get deployment 

$ kubectl describe hpa 
```

#### 스케일 업 일으키기 

```shell
$ kubectl expose deployment kubia --port=80 --target-port=8080 
```

```shell
# 동시에 여러 시소스 관찰하기 
$ watch -n 1 kubectl get hpa,deployment 
```

> kubectl get 명령에 여러 리소스 유형을 쉼표로 구분해 나열한다. 

```shell
$ kubectl run -it  --rm --restart=Never loadgenerator --image=busybox
```

-it 옵션을 kubectl exec 명령을 실행 할 때 몇번 본적 있다. 이 명령은 kubectl run 명령을 실행할 때도 사용할 수 있다.  
이 옵션은 콘솔을 대상 프로세스에 붙여, 프로세스의 출력을 직접 볼 수 있게 해줄 뿐만 아니라 CTRL+C를 눌러 프로세스를 종료할 수도 있다.  
--rm 옵션은 파드가 종료된 후에 삭제하도록 하고 --restart=Never 옵션은 kubectl run 명령이 디플로이먼트 오브젝트를 통해 관리하는 대신, 
관리되지 않는 파드를 직접 만들도록 한다. 이 옵션 조합은 클러스터 안에서 이미 존재하는 파드에 도움을 받지 ㅇ낳고 명령을 실행하는 데 유용하다.  
원하는 명령을 로컬에서 실행하는 것과 동일하게 수행되며, 명령이 종료되면 모든 것을 깨끗하게 정리한다. 

## 수직적 파드 오토스케일링
## 수평적 클러스터 노드 확장 